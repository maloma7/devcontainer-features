name: "Release Dev Container Features"

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      packages: write
      id-token: write        # Required for OIDC token generation (Sigstore)
      attestations: write    # Required for creating attestations
    steps:
      - uses: actions/checkout@v4

      - name: "Publish Features"
        uses: devcontainers/action@v1
        with:
          publish-features: "true"
          base-path-to-features: "./src"
          generate-docs: "true"

        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: "Retrieve Feature Digests and Attest"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          # Auto-discover all features from src directory
          features=($(find ./src -maxdepth 1 -mindepth 1 -type d -exec basename {} \;))

          SUBJECT_NAMES=""
          SUBJECT_DIGESTS=""

          for feature in "${features[@]}"; do
            echo "Processing feature: $feature"

            # Read version from devcontainer-feature.json
            version=$(jq -r '.version' "./src/${feature}/devcontainer-feature.json")
            major_version=$(echo "$version" | cut -d. -f1)

            # Construct image reference (use major version tag)
            image_name="ghcr.io/${{ github.repository }}/${feature}"
            image_ref="${image_name}:${major_version}"

            echo "Fetching digest for: $image_ref"

            # Use docker buildx imagetools (pre-installed on GitHub runners)
            # No additional tools needed!
            digest=$(docker buildx imagetools inspect "$image_ref" \
              --format '{{json .Manifest.Digest}}' | tr -d '"')

            if [ -z "$digest" ] || [ "$digest" = "null" ]; then
              echo "::error::Could not retrieve digest for $image_ref"
              exit 1
            fi

            echo "âœ“ $feature: $digest"

            # Build subject lists (newline-delimited for multi-subject attestation)
            SUBJECT_NAMES="${SUBJECT_NAMES}${image_name}"$'\n'
            SUBJECT_DIGESTS="${SUBJECT_DIGESTS}${digest}"$'\n'
          done

          # Save for attestation step
          echo "SUBJECT_NAMES<<EOF" >> $GITHUB_ENV
          echo "$SUBJECT_NAMES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          echo "SUBJECT_DIGESTS<<EOF" >> $GITHUB_ENV
          echo "$SUBJECT_DIGESTS" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: "Generate Attestations for All Features"
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ${{ env.SUBJECT_NAMES }}
          subject-digest: ${{ env.SUBJECT_DIGESTS }}

      - name: Create PR for Documentation
        id: push_image_info
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          echo "Start."

          # Create new branch for documentation updates
          branch=automated-documentation-update-$GITHUB_RUN_ID
          echo "Creating branch: $branch"

          # Create branch via API (this will be automatically signed)
          gh api \
            --method POST \
            /repos/$GITHUB_REPOSITORY/git/refs \
            -f ref="refs/heads/$branch" \
            -f sha="$GITHUB_SHA"

          message='Automated documentation update [skip ci]'

          # Find all updated README.md files
          readmes=$(find . -name "README.md" -path "*/*/README.md")

          # Check if any README files were found
          if [ -z "$readmes" ]; then
            echo "No README files found to update"
            exit 0
          fi

          # Commit each README file via GitHub API (automatically signed)
          for readme in $readmes; do
            # Get the current file from the source branch to get its SHA
            file_path=${readme:2}  # Remove leading ./
            echo "Committing updates to $file_path"
            
            # Get current file SHA from the new branch
            file_sha=$(gh api \
              --method GET \
              /repos/$GITHUB_REPOSITORY/contents/$file_path?ref=main \
              -q '.sha')
            
            echo "SHA for $file_path: $file_sha"
            
            # Use GitHub API to commit the file (automatically signed)
            gh api \
              --method PUT \
              /repos/$GITHUB_REPOSITORY/contents/$file_path \
              -f message="$message" \
              -f content="$(base64 -i $readme)" \
              -f sha="$file_sha" \
              -f branch="$branch" \
              || echo "No changes to commit for $file_path"
          done

          # Create PR
          gh pr create --title "$message" --body "$message" --head "$branch" --base "main" || echo "No changes to create PR for"
